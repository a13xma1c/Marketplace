"""
This module represents the Marketplace.

Computer Systems Architecture Course
Assignment 1
March 2021
"""
from threading import Lock
from functools import reduce
import operator
import uuid


class Marketplace:
    """
    Class that represents the Marketplace. It's the central part of the implementation.
    The producers and consumers use its methods concurrently.
    """
    def __init__(self, queue_size_per_producer):
        """
        Constructor

        :type queue_size_per_producer: Int
        :param queue_size_per_producer: the maximum size of a queue associated with each producer

        Initializes the consumers' and producers' queues as dictionaries and creates a lock that
        will be used for all operations on shared resources
        """
        self.queue_size_per_producer = queue_size_per_producer
        self.queue_dict = dict()
        self.cart_dict = dict()
        self.lock = Lock()

    def register_producer(self):
        """
        An id is generated using the uuid4 function from the uuid module.
        An empty list entry is added for this id in the producer queue.
        Returns an id for the producer that calls this.
        """
        producer_id = uuid.uuid4()
        self.queue_dict[producer_id] = list()
        return producer_id

    def publish(self, producer_id, product):
        """
        Adds the product provided by the producer to the marketplace

        :type producer_id: String
        :param producer_id: producer id

        :type product: Product
        :param product: the Product that will be published in the Marketplace

        :returns True or False. If the caller receives False, it should wait and then try again.
        """
        self.lock.acquire()
        # check if the producer queue is full
        condition = True
        if len(self.queue_dict[producer_id]) == self.queue_size_per_producer:
            condition = False
        else:
            # add product to the producer queue
            self.queue_dict[producer_id].append(product)
        self.lock.release()

        return condition

    def new_cart(self):
        """
        Creates a new cart for the consumer

        :returns an int representing the cart_id
        """
        self.lock.acquire()
        cart_id = uuid.uuid4()
        self.cart_dict[cart_id] = list()
        self.lock.release()

        return cart_id

    def add_to_cart(self, cart_id, product):
        """
        Adds a product to the given cart.

        :type cart_id: Int
        :param cart_id: id cart

        :type product: Product
        :param product: the product to add to cart

        :returns True or False. If the caller receives False, it should wait and then try again
        """
        self.lock.acquire()
        # check if the product is available in the producers queue
        condition = False
        flat_list = reduce(operator.add, self.queue_dict.values())

        if product in flat_list:
            for key, value in self.queue_dict.items():
                # select the first available product
                if product in value:
                    # remove the product, thus rendering one occurrence unavailable
                    self.queue_dict[key].remove(product)
                    # add the product to the cart with the id corresponding to the origin producer
                    self.cart_dict[cart_id].append((key, product))
                    condition = True
                    break

        self.lock.release()

        return condition

    def remove_from_cart(self, cart_id, product):
        """
        Removes a product from the given cart.

        :type cart_id: Int
        :param cart_id: id cart

        :type product: Product
        :param product: the product to remove from cart
        """
        self.lock.acquire()
        for (key, prod) in self.cart_dict[cart_id]:
            if prod == product:
                # remove a product generated by a producer with id key from a cart
                self.cart_dict[cart_id].remove((key, product))
                # mark the removed product as available in the producer queue
                self.queue_dict[key].append(product)
                break
        self.lock.release()

    def place_order(self, cart_id):
        """
        Return a list with all the products in the cart.

        :type cart_id: Int
        :param cart_id: id cart
        """
        return [p for (k, p) in self.cart_dict[cart_id]]
